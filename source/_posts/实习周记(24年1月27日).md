---
title: 实习周记(24年1月20日)
date: 2024-1-27 18:28:00
tags:
- 前端学习计划
- 前端
- Js
- Vue
categories: 
- 笔记
---

第二周，持续学习

<!-- more -->

#### 1.22

##### md折叠

``` html
<details> 
    <summary>展开查看规范</summary> 
    这是展开后的内容1 
</details>
```

``` diff
const unique = (arr) => {
-	return [...new Set(arr)];
+	return arr.filter((item, index) => arr.indexOf(item) === index)
}
```

当以前没有`Set Map filter`时双重for循环去重


	for (let i = 0, len = arr.length; i < len; i++) {
		for (let j = i + 1; j < len; j++) {
			if (arr[j] === arr[i]) {
				arr.splice(j, 1);
				j--;
				len--;
			}
		}
	}
	return arr

刚好复习下js数组去重

##### 修改windows hosts

C:\Windows\System32\drivers\etc\hosts

##### js执行上下文

- 全局执行上下文
- 函数执行上下文
- eval执行上下文

##### js执行栈

函数首次运行JS代码时，会创建一个**全局**执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个**新的函数**执行上下文并Push到当前执行栈的栈顶。

根据执行栈LIFO规则，当栈顶函数运行完成后，其对应的**函数**执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的**下一个**执行上下文。

执行上下文分两个阶段创建：**1）创建阶段；** **2）执行阶段**

- 1、确定 **this** 的值，也被称为 **This Binding**。
- 2、**LexicalEnvironment（词法环境）** 组件被创建。
- 3、**VariableEnvironment（变量环境）** 组件被创建。

伪代码

```js
ExecutionContext = {  
  ThisBinding = <this value>,     // 确定this 
  LexicalEnvironment = { ... },   // 词法环境
  VariableEnvironment = { ... },  // 变量环境
}
```

##### 词法环境

```js
GlobalExectionContext = {  // 全局执行上下文
  LexicalEnvironment: {    	  // 词法环境
    EnvironmentRecord: {   		// 环境记录
      Type: "Object",      		   // 全局环境
      // 标识符绑定在这里 
      outer: <null>  	   		   // 对外部环境的引用
  }  
}

FunctionExectionContext = { // 函数执行上下文
  LexicalEnvironment: {  	  // 词法环境
    EnvironmentRecord: {  		// 环境记录
      Type: "Declarative",  	   // 函数环境
      // 标识符绑定在这里 			  // 对外部环境的引用
      outer: <Global or outer function environment reference>  
  }  
}
```



变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。

在 ES6 中，**词法** 环境和 **变量** 环境的区别在于前者用于存储**函数声明和变量（ `let` 和 `const` ）**绑定，而后者仅用于存储**变量（ `var` ）**绑定。

这里能解释变量提升的原因【是因为undefied就可以吗】

##### 执行阶段

此阶段，完成对所有变量的分配，最后执行代码。

如果 Javascript 引擎在源代码中声明的实际位置找不到 `let` 变量的值，那么将为其分配 `undefined` 值。

##### 【VUE】Cannot read properties of undefined (reading ‘_wrapper‘)

原因：button按钮存在没有卸载methods里的点击事件

解决：定义未定义的方法

##### 对于是否是ie的判断

``` js
 isIE(userAgent) {

  var UA = userAgent || navigator.userAgent;

  if ((/msie/i).test(UA)) {

   return UA.match(/msie (\d+\.\d+)/i)[1];

  } else if (~UA.toLowerCase().indexOf('trident') && ~UA.indexOf('rv')) {

   return UA.match(/rv:(\d+\.\d+)/)[1];

  }

  return false;

 },
```



```js
/ISAPI/Bumblebee/Platform/V1/PersonCredential/ThirdPartyEventsCount      获取所有条数
PostGet
IN

{
	"RequestAlarmLogList": {
		"BeginTime": "2024-01-22T05:32:08Z",
		"EndTime": "2024-01-22T06:32:08Z",
		"EventTypes "1111,12222,1121212",
		"DeviceID": 1,       //0 表示所有
		"DoorName": "Test",  //传空 表示所有
		"SourceType":0      //0:所有；   1:Ambiance；  2: CMatrix
	
	}
}

OUT：
{
	"ResponseStatus": {
		"ErrorModule": 0,
		"ErrorCode": 0,
		"Data": {
			"ResponseAlarmLogList": {
				"TotalNum": 1
			}
		}
	}
}


/ISAPI/Bumblebee/Platform/V1/PersonCredential/ThirdPartyEvents
PostGet
IN

{
	"RequestAlarmLogList": {
		"PageIndex": 100,
		"PageSize": 1,
		"BeginTime": "2024-01-22T05:32:08Z",
		"EndTime": "2024-01-22T06:32:08Z",
		"EventTypes "1111,12222,1121212",
		"DeviceID": 1,       //0 表示所有
		"DoorName": "Test",  //传空 表示所有
		"SourceType":0      //0:所有；   1:Ambiance；  2: CMatrix
	
	}
}

Out
{
	"ResponseStatus": {
		"Data": {
			"ResponseLogList": {
				"PageIndex": 1,
				"PageSize": 1,
				"LogList": [
					{
						"EventID": 123,
						"EventName": "test",
						"DeviceID": 111,
						"DoorName": "1111",
						"SourceType":1,
						"HappenTime": "2024-01-22 06:32:01",
					}
				],
			}
		},
		"ErrorModule": 0,
		"ErrorCode": 0
	}
}
```

